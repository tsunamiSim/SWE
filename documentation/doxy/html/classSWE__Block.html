<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>SWE: SWE_Block Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SWE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classSWE__Block-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SWE_Block Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="SWE__Block_8hh_source.html">SWE_Block.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SWE_Block:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSWE__Block.png" usemap="#SWE_Block_map" alt=""/>
  <map id="SWE_Block_map" name="SWE_Block_map">
<area href="classSWE__BlockCUDA.html" alt="SWE_BlockCUDA" shape="rect" coords="109,56,317,80"/>
<area href="classSWE__DimensionalSplitting.html" alt="SWE_DimensionalSplitting" shape="rect" coords="327,56,535,80"/>
<area href="classSWE__RusanovBlock.html" alt="SWE_RusanovBlock" shape="rect" coords="545,56,753,80"/>
<area href="classSWE__WaveAccumulationBlock.html" alt="SWE_WaveAccumulationBlock" shape="rect" coords="763,56,971,80"/>
<area href="classSWE__WavePropagationBlock.html" alt="SWE_WavePropagationBlock" shape="rect" coords="981,56,1189,80"/>
<area href="classSWE__WavePropagationBlockSIMD.html" alt="SWE_WavePropagationBlockSIMD" shape="rect" coords="1199,56,1407,80"/>
<area href="classSWE__RusanovBlockCUDA.html" alt="SWE_RusanovBlockCUDA" shape="rect" coords="0,112,208,136"/>
<area href="classSWE__WavePropagationBlockCuda.html" alt="SWE_WavePropagationBlockCuda" shape="rect" coords="218,112,426,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a46b715c584468a5daa975ec1eb1ab947"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a46b715c584468a5daa975ec1eb1ab947">initScenario</a> (float _offsetX, float _offsetY, <a class="el" href="classSWE__Scenario.html">SWE_Scenario</a> &amp;i_scenario, const bool i_multipleBlocks=false)</td></tr>
<tr class="memdesc:a46b715c584468a5daa975ec1eb1ab947"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialise unknowns to a specific scenario:  <a href="#a46b715c584468a5daa975ec1eb1ab947">More...</a><br/></td></tr>
<tr class="separator:a46b715c584468a5daa975ec1eb1ab947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6481ce1c80a219fbefefdcbd13ed3688"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a6481ce1c80a219fbefefdcbd13ed3688">setWaterHeight</a> (float(*_h)(float, float))</td></tr>
<tr class="memdesc:a6481ce1c80a219fbefefdcbd13ed3688"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the water height according to a given function  <a href="#a6481ce1c80a219fbefefdcbd13ed3688">More...</a><br/></td></tr>
<tr class="separator:a6481ce1c80a219fbefefdcbd13ed3688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245332c325fd0ff6a7e9c2d3d9454970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a245332c325fd0ff6a7e9c2d3d9454970">setDischarge</a> (float(*_u)(float, float), float(*_v)(float, float))</td></tr>
<tr class="memdesc:a245332c325fd0ff6a7e9c2d3d9454970"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the momentum/discharge according to the provided functions  <a href="#a245332c325fd0ff6a7e9c2d3d9454970">More...</a><br/></td></tr>
<tr class="separator:a245332c325fd0ff6a7e9c2d3d9454970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ab34b138a14f2c295849f3b2acc5f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#af2ab34b138a14f2c295849f3b2acc5f3">setBathymetry</a> (float _b)</td></tr>
<tr class="memdesc:af2ab34b138a14f2c295849f3b2acc5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the bathymetry to a uniform value  <a href="#af2ab34b138a14f2c295849f3b2acc5f3">More...</a><br/></td></tr>
<tr class="separator:af2ab34b138a14f2c295849f3b2acc5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4214fcfd102a4c167d274ad87d9dd90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#ad4214fcfd102a4c167d274ad87d9dd90">setBathymetry</a> (float(*_b)(float, float))</td></tr>
<tr class="memdesc:ad4214fcfd102a4c167d274ad87d9dd90"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the bathymetry according to a given function  <a href="#ad4214fcfd102a4c167d274ad87d9dd90">More...</a><br/></td></tr>
<tr class="separator:ad4214fcfd102a4c167d274ad87d9dd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e750bb5e8a952cd9f771054cb4e7b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#ab2e750bb5e8a952cd9f771054cb4e7b0">setBathymetry</a> (float *_b)</td></tr>
<tr class="memdesc:ab2e750bb5e8a952cd9f771054cb4e7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the whole bathymetry matrix  <a href="#ab2e750bb5e8a952cd9f771054cb4e7b0">More...</a><br/></td></tr>
<tr class="separator:ab2e750bb5e8a952cd9f771054cb4e7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d2adb939d59e064edd7316faae445f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a54d2adb939d59e064edd7316faae445f">setBathymetry</a> (int i_x, int i_y, float i_b)</td></tr>
<tr class="memdesc:a54d2adb939d59e064edd7316faae445f"><td class="mdescLeft">&#160;</td><td class="mdescRight">set one single cell's bathymetry value  <a href="#a54d2adb939d59e064edd7316faae445f">More...</a><br/></td></tr>
<tr class="separator:a54d2adb939d59e064edd7316faae445f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1aea4294403c194180c3dc107339fd7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFloat2D.html">Float2D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#ab1aea4294403c194180c3dc107339fd7">getWaterHeight</a> ()</td></tr>
<tr class="memdesc:ab1aea4294403c194180c3dc107339fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">provides read access to the water height array  <a href="#ab1aea4294403c194180c3dc107339fd7">More...</a><br/></td></tr>
<tr class="separator:ab1aea4294403c194180c3dc107339fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e766626a1e3fee89625610e2c67f1f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFloat2D.html">Float2D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#ae5e766626a1e3fee89625610e2c67f1f">getDischarge_hu</a> ()</td></tr>
<tr class="memdesc:ae5e766626a1e3fee89625610e2c67f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">provides read access to the momentum/discharge array (x-component)  <a href="#ae5e766626a1e3fee89625610e2c67f1f">More...</a><br/></td></tr>
<tr class="separator:ae5e766626a1e3fee89625610e2c67f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece9e8dc3f9b8ab27420e537c76daf7c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFloat2D.html">Float2D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#aece9e8dc3f9b8ab27420e537c76daf7c">getDischarge_hv</a> ()</td></tr>
<tr class="memdesc:aece9e8dc3f9b8ab27420e537c76daf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">provides read access to the momentum/discharge array (y-component)  <a href="#aece9e8dc3f9b8ab27420e537c76daf7c">More...</a><br/></td></tr>
<tr class="separator:aece9e8dc3f9b8ab27420e537c76daf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e2c99a335d11d09a1489d6873b5615"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFloat2D.html">Float2D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a98e2c99a335d11d09a1489d6873b5615">getBathymetry</a> ()</td></tr>
<tr class="memdesc:a98e2c99a335d11d09a1489d6873b5615"><td class="mdescLeft">&#160;</td><td class="mdescRight">provides read access to the bathymetry data  <a href="#a98e2c99a335d11d09a1489d6873b5615">More...</a><br/></td></tr>
<tr class="separator:a98e2c99a335d11d09a1489d6873b5615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa220b93e43b10f56c72a44d7363645c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#aa220b93e43b10f56c72a44d7363645c1">setBoundaryType</a> (<a class="el" href="SWE__Scenario_8hh.html#aa5e01e3f7df312f7b9b0d02521141fcc">BoundaryEdge</a> edge, <a class="el" href="SWE__Scenario_8hh.html#af75d5dd7322fa39ed0af4e7839e600f8">BoundaryType</a> boundtype, const <a class="el" href="structSWE__Block1D.html">SWE_Block1D</a> *inflow=NULL)</td></tr>
<tr class="memdesc:aa220b93e43b10f56c72a44d7363645c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">set type of boundary condition for the specified boundary  <a href="#aa220b93e43b10f56c72a44d7363645c1">More...</a><br/></td></tr>
<tr class="separator:aa220b93e43b10f56c72a44d7363645c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827ee5c61dc9c1b472ac8b4e1c19956a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structSWE__Block1D.html">SWE_Block1D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a827ee5c61dc9c1b472ac8b4e1c19956a">registerCopyLayer</a> (<a class="el" href="SWE__Scenario_8hh.html#aa5e01e3f7df312f7b9b0d02521141fcc">BoundaryEdge</a> edge)</td></tr>
<tr class="memdesc:a827ee5c61dc9c1b472ac8b4e1c19956a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a pointer to proxy class to access the copy layer  <a href="#a827ee5c61dc9c1b472ac8b4e1c19956a">More...</a><br/></td></tr>
<tr class="separator:a827ee5c61dc9c1b472ac8b4e1c19956a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a96c59444645e237d098803009158a3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structSWE__Block1D.html">SWE_Block1D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a9a96c59444645e237d098803009158a3">grabGhostLayer</a> (<a class="el" href="SWE__Scenario_8hh.html#aa5e01e3f7df312f7b9b0d02521141fcc">BoundaryEdge</a> edge)</td></tr>
<tr class="memdesc:a9a96c59444645e237d098803009158a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">"grab" the ghost layer in order to set these values externally  <a href="#a9a96c59444645e237d098803009158a3">More...</a><br/></td></tr>
<tr class="separator:a9a96c59444645e237d098803009158a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd17334abee3145e27cc3c9b7b935da2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#afd17334abee3145e27cc3c9b7b935da2">setGhostLayer</a> ()</td></tr>
<tr class="memdesc:afd17334abee3145e27cc3c9b7b935da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">set values in ghost layers  <a href="#afd17334abee3145e27cc3c9b7b935da2">More...</a><br/></td></tr>
<tr class="separator:afd17334abee3145e27cc3c9b7b935da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74da1eb712e639e47b5b848081b2afad"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a74da1eb712e639e47b5b848081b2afad">getMaxTimestep</a> ()</td></tr>
<tr class="memdesc:a74da1eb712e639e47b5b848081b2afad"><td class="mdescLeft">&#160;</td><td class="mdescRight">return maximum size of the time step to ensure stability of the method  <a href="#a74da1eb712e639e47b5b848081b2afad">More...</a><br/></td></tr>
<tr class="separator:a74da1eb712e639e47b5b848081b2afad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2ff6617cbc0d3d837f0e618039cfe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#acf2ff6617cbc0d3d837f0e618039cfe2">computeMaxTimestep</a> (const float i_dryTol=0.1, const float i_cflNumber=0.4)</td></tr>
<tr class="separator:acf2ff6617cbc0d3d837f0e618039cfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6908e1ceb261a0a1f3ebc262cc5f11"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#add6908e1ceb261a0a1f3ebc262cc5f11">simulateTimestep</a> (float dt)</td></tr>
<tr class="memdesc:add6908e1ceb261a0a1f3ebc262cc5f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">execute a single time step (with fixed time step size) of the simulation  <a href="#add6908e1ceb261a0a1f3ebc262cc5f11">More...</a><br/></td></tr>
<tr class="separator:add6908e1ceb261a0a1f3ebc262cc5f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69784e2be2d09035fb2af9d306768f07"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a69784e2be2d09035fb2af9d306768f07">simulate</a> (float tStart, float tEnd)</td></tr>
<tr class="separator:a69784e2be2d09035fb2af9d306768f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dcf2c6ae31731e4586e45628b0c00e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a94dcf2c6ae31731e4586e45628b0c00e">computeNumericalFluxes</a> ()=0</td></tr>
<tr class="memdesc:a94dcf2c6ae31731e4586e45628b0c00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the numerical fluxes for each edge of the Cartesian grid  <a href="#a94dcf2c6ae31731e4586e45628b0c00e">More...</a><br/></td></tr>
<tr class="separator:a94dcf2c6ae31731e4586e45628b0c00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b4b659f23d5d45413dece8d2da3298"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#ab2b4b659f23d5d45413dece8d2da3298">updateUnknowns</a> (float dt)=0</td></tr>
<tr class="memdesc:ab2b4b659f23d5d45413dece8d2da3298"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the new values of the unknowns h, hu, and hv in all grid cells  <a href="#ab2b4b659f23d5d45413dece8d2da3298">More...</a><br/></td></tr>
<tr class="separator:ab2b4b659f23d5d45413dece8d2da3298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27028fa4bc13bb2d9251b09e0fdfce6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa27028fa4bc13bb2d9251b09e0fdfce6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#aa27028fa4bc13bb2d9251b09e0fdfce6">getNx</a> ()</td></tr>
<tr class="memdesc:aa27028fa4bc13bb2d9251b09e0fdfce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classSWE__Block.html#a46ec0dc1157997bd255fb39924f1e2bb" title="size of Cartesian arrays in x-direction ">nx</a>, i.e. the grid size in x-direction <br/></td></tr>
<tr class="separator:aa27028fa4bc13bb2d9251b09e0fdfce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b65557b6f73ffb6454dad3dbf86e9ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b65557b6f73ffb6454dad3dbf86e9ad"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a4b65557b6f73ffb6454dad3dbf86e9ad">getNy</a> ()</td></tr>
<tr class="memdesc:a4b65557b6f73ffb6454dad3dbf86e9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classSWE__Block.html#a3f139630d12423eb4bd7df3e45c7f5da" title="size of Cartesian arrays in y-direction ">ny</a>, i.e. the grid size in y-direction <br/></td></tr>
<tr class="separator:a4b65557b6f73ffb6454dad3dbf86e9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4b3b3a932f3895c4f013cd4bb319d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d4b3b3a932f3895c4f013cd4bb319d3"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a2d4b3b3a932f3895c4f013cd4bb319d3">getDx</a> ()</td></tr>
<tr class="memdesc:a2d4b3b3a932f3895c4f013cd4bb319d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classSWE__Block.html#af2262b1cce6834d939c5a2315dae49b1" title="mesh size of the Cartesian grid in x-direction ">dx</a>, i.e. the cell size in x-direction <br/></td></tr>
<tr class="separator:a2d4b3b3a932f3895c4f013cd4bb319d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4edc5f146a02c00187a81d93f00fb7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add4edc5f146a02c00187a81d93f00fb7"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#add4edc5f146a02c00187a81d93f00fb7">getDy</a> ()</td></tr>
<tr class="memdesc:add4edc5f146a02c00187a81d93f00fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classSWE__Block.html#a9feb988748d792bca0ca0508e43bd87f" title="mesh size of the Cartesian grid in y-direction ">dy</a>, i.e. the cell size in y-direction <br/></td></tr>
<tr class="separator:add4edc5f146a02c00187a81d93f00fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f279d69697c335d5e9c9c4d3c54e3b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f279d69697c335d5e9c9c4d3c54e3b8"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a5f279d69697c335d5e9c9c4d3c54e3b8">getOffx</a> ()</td></tr>
<tr class="memdesc:a5f279d69697c335d5e9c9c4d3c54e3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return <a class="el" href="classSWE__Block.html#aa9e9b1fa797c133c4989e4c54f09b542" title="x-coordinate of the origin (left-bottom corner) of the Cartesian grid ">offsetX</a>, i.e. the x-origin of the coordinate system <br/></td></tr>
<tr class="separator:a5f279d69697c335d5e9c9c4d3c54e3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22364064412b824204dc8a79bf572893"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22364064412b824204dc8a79bf572893"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a22364064412b824204dc8a79bf572893">getOffy</a> ()</td></tr>
<tr class="memdesc:a22364064412b824204dc8a79bf572893"><td class="mdescLeft">&#160;</td><td class="mdescRight">return <a class="el" href="classSWE__Block.html#aa05241101a66f0f0548eba6dbbaa1bbb" title="y-coordinate of the origin (left-bottom corner) of the Cartesian grid ">offsetY</a>, i.e. the y-origin of the coordinate system <br/></td></tr>
<tr class="separator:a22364064412b824204dc8a79bf572893"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a073ca743ff4077a7e456906be704958f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a073ca743ff4077a7e456906be704958f"></a>
static const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a073ca743ff4077a7e456906be704958f">g</a> = 9.81f</td></tr>
<tr class="memdesc:a073ca743ff4077a7e456906be704958f"><td class="mdescLeft">&#160;</td><td class="mdescRight">static variable that holds the gravity constant (g = 9.81 m/s^2): <br/></td></tr>
<tr class="separator:a073ca743ff4077a7e456906be704958f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a114ed3bb6a8a2c482e5f94f768543b82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a114ed3bb6a8a2c482e5f94f768543b82">SWE_Block</a> (int l_nx, int l_ny, float l_dx, float l_dy)</td></tr>
<tr class="separator:a114ed3bb6a8a2c482e5f94f768543b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddff1c284663ba514985a3574def1b0"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a2ddff1c284663ba514985a3574def1b0">~SWE_Block</a> ()</td></tr>
<tr class="separator:a2ddff1c284663ba514985a3574def1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6beb68dacde9c8479647c25c6a5cbcf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a6beb68dacde9c8479647c25c6a5cbcf5">setBoundaryBathymetry</a> ()</td></tr>
<tr class="separator:a6beb68dacde9c8479647c25c6a5cbcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae914f9bf6d4ef8f974f9f005114985e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#ae914f9bf6d4ef8f974f9f005114985e7">synchAfterWrite</a> ()</td></tr>
<tr class="separator:ae914f9bf6d4ef8f974f9f005114985e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2924833e29a795d8c04fb79bfe794de"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#aa2924833e29a795d8c04fb79bfe794de">synchWaterHeightAfterWrite</a> ()</td></tr>
<tr class="separator:aa2924833e29a795d8c04fb79bfe794de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c34030153178c9d94f3f14be174eaf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a94c34030153178c9d94f3f14be174eaf">synchDischargeAfterWrite</a> ()</td></tr>
<tr class="separator:a94c34030153178c9d94f3f14be174eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bece8aa90f67e55c40b91aab900febb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a4bece8aa90f67e55c40b91aab900febb">synchBathymetryAfterWrite</a> ()</td></tr>
<tr class="separator:a4bece8aa90f67e55c40b91aab900febb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4657993ebdb5f0132b077e63790d0b2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a4657993ebdb5f0132b077e63790d0b2b">synchGhostLayerAfterWrite</a> ()</td></tr>
<tr class="separator:a4657993ebdb5f0132b077e63790d0b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d936cb9a4367092e5b2515f81fe819"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a23d936cb9a4367092e5b2515f81fe819">synchBeforeRead</a> ()</td></tr>
<tr class="separator:a23d936cb9a4367092e5b2515f81fe819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c85681ab29106c3b164db969899ace"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a07c85681ab29106c3b164db969899ace">synchWaterHeightBeforeRead</a> ()</td></tr>
<tr class="separator:a07c85681ab29106c3b164db969899ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3773dcb194212fb8cb40ab8465575aa1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a3773dcb194212fb8cb40ab8465575aa1">synchDischargeBeforeRead</a> ()</td></tr>
<tr class="separator:a3773dcb194212fb8cb40ab8465575aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8258c6949518ca44f4e9ce89d33b09"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a7c8258c6949518ca44f4e9ce89d33b09">synchBathymetryBeforeRead</a> ()</td></tr>
<tr class="separator:a7c8258c6949518ca44f4e9ce89d33b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c90d5a6596336013c41e73c8795f83"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a13c90d5a6596336013c41e73c8795f83">synchCopyLayerBeforeRead</a> ()</td></tr>
<tr class="separator:a13c90d5a6596336013c41e73c8795f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379807f0bf932b40aeb42065633fce60"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a379807f0bf932b40aeb42065633fce60">setBoundaryConditions</a> ()</td></tr>
<tr class="memdesc:a379807f0bf932b40aeb42065633fce60"><td class="mdescLeft">&#160;</td><td class="mdescRight">set boundary conditions in ghost layers (set boundary conditions)  <a href="#a379807f0bf932b40aeb42065633fce60">More...</a><br/></td></tr>
<tr class="separator:a379807f0bf932b40aeb42065633fce60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a46ec0dc1157997bd255fb39924f1e2bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46ec0dc1157997bd255fb39924f1e2bb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a46ec0dc1157997bd255fb39924f1e2bb">nx</a></td></tr>
<tr class="memdesc:a46ec0dc1157997bd255fb39924f1e2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of Cartesian arrays in x-direction <br/></td></tr>
<tr class="separator:a46ec0dc1157997bd255fb39924f1e2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f139630d12423eb4bd7df3e45c7f5da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f139630d12423eb4bd7df3e45c7f5da"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a3f139630d12423eb4bd7df3e45c7f5da">ny</a></td></tr>
<tr class="memdesc:a3f139630d12423eb4bd7df3e45c7f5da"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of Cartesian arrays in y-direction <br/></td></tr>
<tr class="separator:a3f139630d12423eb4bd7df3e45c7f5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2262b1cce6834d939c5a2315dae49b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2262b1cce6834d939c5a2315dae49b1"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#af2262b1cce6834d939c5a2315dae49b1">dx</a></td></tr>
<tr class="memdesc:af2262b1cce6834d939c5a2315dae49b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">mesh size of the Cartesian grid in x-direction <br/></td></tr>
<tr class="separator:af2262b1cce6834d939c5a2315dae49b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9feb988748d792bca0ca0508e43bd87f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9feb988748d792bca0ca0508e43bd87f"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a9feb988748d792bca0ca0508e43bd87f">dy</a></td></tr>
<tr class="memdesc:a9feb988748d792bca0ca0508e43bd87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">mesh size of the Cartesian grid in y-direction <br/></td></tr>
<tr class="separator:a9feb988748d792bca0ca0508e43bd87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a0f8f437f38b5f3b8ec5b4abdb864e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64a0f8f437f38b5f3b8ec5b4abdb864e"></a>
<a class="el" href="classFloat2D.html">Float2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a64a0f8f437f38b5f3b8ec5b4abdb864e">h</a></td></tr>
<tr class="memdesc:a64a0f8f437f38b5f3b8ec5b4abdb864e"><td class="mdescLeft">&#160;</td><td class="mdescRight">array that holds the water height for each element <br/></td></tr>
<tr class="separator:a64a0f8f437f38b5f3b8ec5b4abdb864e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2c1278fdb23f083216d8d397f26060"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec2c1278fdb23f083216d8d397f26060"></a>
<a class="el" href="classFloat2D.html">Float2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#aec2c1278fdb23f083216d8d397f26060">hu</a></td></tr>
<tr class="memdesc:aec2c1278fdb23f083216d8d397f26060"><td class="mdescLeft">&#160;</td><td class="mdescRight">array that holds the x-component of the momentum for each element (water height h multiplied by velocity in x-direction) <br/></td></tr>
<tr class="separator:aec2c1278fdb23f083216d8d397f26060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0897aa3c2d78749f209c95e08196d831"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0897aa3c2d78749f209c95e08196d831"></a>
<a class="el" href="classFloat2D.html">Float2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a0897aa3c2d78749f209c95e08196d831">hv</a></td></tr>
<tr class="memdesc:a0897aa3c2d78749f209c95e08196d831"><td class="mdescLeft">&#160;</td><td class="mdescRight">array that holds the y-component of the momentum for each element (water height h multiplied by velocity in y-direction) <br/></td></tr>
<tr class="separator:a0897aa3c2d78749f209c95e08196d831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7487209129f40b26ea171762754a261"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7487209129f40b26ea171762754a261"></a>
<a class="el" href="classFloat2D.html">Float2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#af7487209129f40b26ea171762754a261">b</a></td></tr>
<tr class="memdesc:af7487209129f40b26ea171762754a261"><td class="mdescLeft">&#160;</td><td class="mdescRight">array that holds the bathymetry data (sea floor elevation) for each element <br/></td></tr>
<tr class="separator:af7487209129f40b26ea171762754a261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e56d0cad169abd4f5de95d9f96c7a73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e56d0cad169abd4f5de95d9f96c7a73"></a>
<a class="el" href="SWE__Scenario_8hh.html#af75d5dd7322fa39ed0af4e7839e600f8">BoundaryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a0e56d0cad169abd4f5de95d9f96c7a73">boundary</a> [4]</td></tr>
<tr class="memdesc:a0e56d0cad169abd4f5de95d9f96c7a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of boundary conditions at LEFT, RIGHT, TOP, and BOTTOM boundary <br/></td></tr>
<tr class="separator:a0e56d0cad169abd4f5de95d9f96c7a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea4ea4815af9eb66c51de9ad9b8d148"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ea4ea4815af9eb66c51de9ad9b8d148"></a>
const <a class="el" href="structSWE__Block1D.html">SWE_Block1D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a5ea4ea4815af9eb66c51de9ad9b8d148">neighbour</a> [4]</td></tr>
<tr class="memdesc:a5ea4ea4815af9eb66c51de9ad9b8d148"><td class="mdescLeft">&#160;</td><td class="mdescRight">for CONNECT boundaries: pointer to connected neighbour block <br/></td></tr>
<tr class="separator:a5ea4ea4815af9eb66c51de9ad9b8d148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cbc9b40e0483bf73dbc2bdeae7dee3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#a05cbc9b40e0483bf73dbc2bdeae7dee3">maxTimestep</a></td></tr>
<tr class="memdesc:a05cbc9b40e0483bf73dbc2bdeae7dee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum time step allowed to ensure stability of the method  <a href="#a05cbc9b40e0483bf73dbc2bdeae7dee3">More...</a><br/></td></tr>
<tr class="separator:a05cbc9b40e0483bf73dbc2bdeae7dee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e9b1fa797c133c4989e4c54f09b542"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9e9b1fa797c133c4989e4c54f09b542"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#aa9e9b1fa797c133c4989e4c54f09b542">offsetX</a></td></tr>
<tr class="memdesc:aa9e9b1fa797c133c4989e4c54f09b542"><td class="mdescLeft">&#160;</td><td class="mdescRight">x-coordinate of the origin (left-bottom corner) of the Cartesian grid <br/></td></tr>
<tr class="separator:aa9e9b1fa797c133c4989e4c54f09b542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05241101a66f0f0548eba6dbbaa1bbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa05241101a66f0f0548eba6dbbaa1bbb"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSWE__Block.html#aa05241101a66f0f0548eba6dbbaa1bbb">offsetY</a></td></tr>
<tr class="memdesc:aa05241101a66f0f0548eba6dbbaa1bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">y-coordinate of the origin (left-bottom corner) of the Cartesian grid <br/></td></tr>
<tr class="separator:aa05241101a66f0f0548eba6dbbaa1bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classSWE__Block.html">SWE_Block</a> is the main data structure to compute our shallow water model on a single Cartesian grid block: <a class="el" href="classSWE__Block.html">SWE_Block</a> is an abstract class (and interface) that should be extended by respective implementation classes.</p>
<h3>Cartesian Grid for Discretization:</h3>
<p>SWE_Blocks uses a regular Cartesian grid of size <a class="el" href="classSWE__Block.html#a46ec0dc1157997bd255fb39924f1e2bb" title="size of Cartesian arrays in x-direction ">nx</a> by <a class="el" href="classSWE__Block.html#a3f139630d12423eb4bd7df3e45c7f5da" title="size of Cartesian arrays in y-direction ">ny</a>, where each grid cell carries three unknowns:</p>
<ul>
<li>the water level <a class="el" href="classSWE__Block.html#a64a0f8f437f38b5f3b8ec5b4abdb864e" title="array that holds the water height for each element ">h</a></li>
<li>the momentum components <a class="el" href="classSWE__Block.html#aec2c1278fdb23f083216d8d397f26060" title="array that holds the x-component of the momentum for each element (water height h multiplied by veloc...">hu</a> and <a class="el" href="classSWE__Block.html#a0897aa3c2d78749f209c95e08196d831" title="array that holds the y-component of the momentum for each element (water height h multiplied by veloc...">hv</a> (in x- and y- direction, resp.)</li>
<li>the bathymetry <a class="el" href="classSWE__Block.html#af7487209129f40b26ea171762754a261" title="array that holds the bathymetry data (sea floor elevation) for each element ">b</a></li>
</ul>
<p>Each of the components is stored as a 2D array, implemented as a <a class="el" href="classFloat2D.html">Float2D</a> object, and are defined on grid indices [0,..,<a class="el" href="classSWE__Block.html#a46ec0dc1157997bd255fb39924f1e2bb" title="size of Cartesian arrays in x-direction ">nx</a>+1]*[0,..,<a class="el" href="classSWE__Block.html#a3f139630d12423eb4bd7df3e45c7f5da" title="size of Cartesian arrays in y-direction ">ny</a>+1]. The computational domain is indexed with [1,..,<a class="el" href="classSWE__Block.html#a46ec0dc1157997bd255fb39924f1e2bb" title="size of Cartesian arrays in x-direction ">nx</a>]*[1,..,<a class="el" href="classSWE__Block.html#a3f139630d12423eb4bd7df3e45c7f5da" title="size of Cartesian arrays in y-direction ">ny</a>].</p>
<p>The mesh sizes of the grid in x- and y-direction are stored in static variables <a class="el" href="classSWE__Block.html#af2262b1cce6834d939c5a2315dae49b1" title="mesh size of the Cartesian grid in x-direction ">dx</a> and <a class="el" href="classSWE__Block.html#a9feb988748d792bca0ca0508e43bd87f" title="mesh size of the Cartesian grid in y-direction ">dy</a>. The position of the Cartesian grid in space is stored via the coordinates of the left-bottom corner of the grid, in the variables <a class="el" href="classSWE__Block.html#aa9e9b1fa797c133c4989e4c54f09b542" title="x-coordinate of the origin (left-bottom corner) of the Cartesian grid ">offsetX</a> and <a class="el" href="classSWE__Block.html#aa05241101a66f0f0548eba6dbbaa1bbb" title="y-coordinate of the origin (left-bottom corner) of the Cartesian grid ">offsetY</a>.</p>
<h3>Ghost layers:</h3>
<p>To implement the behaviour of the fluid at boundaries and for using multiple block in serial and parallel settings, <a class="el" href="classSWE__Block.html">SWE_Block</a> adds an additional layer of so-called ghost cells to the Cartesian grid, as illustrated in the following figure. Cells in the ghost layer have indices 0 or <a class="el" href="classSWE__Block.html#a46ec0dc1157997bd255fb39924f1e2bb" title="size of Cartesian arrays in x-direction ">nx</a>+1 / <a class="el" href="classSWE__Block.html#a3f139630d12423eb4bd7df3e45c7f5da" title="size of Cartesian arrays in y-direction ">ny</a>+1.</p>
<div class="image">
<img src="ghost_cells.gif" alt="ghost_cells.gif"/>
</div>
<h3>Memory Model:</h3>
<p>The variables <a class="el" href="classSWE__Block.html#a64a0f8f437f38b5f3b8ec5b4abdb864e" title="array that holds the water height for each element ">h</a>, <a class="el" href="classSWE__Block.html#aec2c1278fdb23f083216d8d397f26060" title="array that holds the x-component of the momentum for each element (water height h multiplied by veloc...">hu</a>, <a class="el" href="classSWE__Block.html#a0897aa3c2d78749f209c95e08196d831" title="array that holds the y-component of the momentum for each element (water height h multiplied by veloc...">hv</a> for water height and momentum will typically be updated by classes derived from <a class="el" href="classSWE__Block.html">SWE_Block</a>. However, it is not assumed that such and updated will be performed in every time step. Instead, subclasses are welcome to update <a class="el" href="classSWE__Block.html#a64a0f8f437f38b5f3b8ec5b4abdb864e" title="array that holds the water height for each element ">h</a>, <a class="el" href="classSWE__Block.html#aec2c1278fdb23f083216d8d397f26060" title="array that holds the x-component of the momentum for each element (water height h multiplied by veloc...">hu</a>, and <a class="el" href="classSWE__Block.html#a0897aa3c2d78749f209c95e08196d831" title="array that holds the y-component of the momentum for each element (water height h multiplied by veloc...">hv</a> in a lazy fashion, and keep data in faster memory (incl. local memory of acceleration hardware, such as GPGPUs), instead.</p>
<p>It is assumed that the bathymetry data <a class="el" href="classSWE__Block.html#af7487209129f40b26ea171762754a261" title="array that holds the bathymetry data (sea floor elevation) for each element ">b</a> is not changed during the algorithm (up to the exceptions mentioned in the following).</p>
<p>To force a synchronization of the respective data structures, the following methods are provided as part of <a class="el" href="classSWE__Block.html">SWE_Block</a>:</p>
<ul>
<li><a class="el" href="classSWE__Block.html#ae914f9bf6d4ef8f974f9f005114985e7">synchAfterWrite()</a> to synchronize <a class="el" href="classSWE__Block.html#a64a0f8f437f38b5f3b8ec5b4abdb864e" title="array that holds the water height for each element ">h</a>, <a class="el" href="classSWE__Block.html#aec2c1278fdb23f083216d8d397f26060" title="array that holds the x-component of the momentum for each element (water height h multiplied by veloc...">hu</a>, <a class="el" href="classSWE__Block.html#a0897aa3c2d78749f209c95e08196d831" title="array that holds the y-component of the momentum for each element (water height h multiplied by veloc...">hv</a>, and <a class="el" href="classSWE__Block.html#af7487209129f40b26ea171762754a261" title="array that holds the bathymetry data (sea floor elevation) for each element ">b</a> after an external update (reading a file, e.g.);</li>
<li><a class="el" href="classSWE__Block.html#aa2924833e29a795d8c04fb79bfe794de">synchWaterHeightAfterWrite()</a>, <a class="el" href="classSWE__Block.html#a94c34030153178c9d94f3f14be174eaf">synchDischargeAfterWrite()</a>, <a class="el" href="classSWE__Block.html#a4bece8aa90f67e55c40b91aab900febb">synchBathymetryAfterWrite()</a>: to synchronize only <a class="el" href="classSWE__Block.html#a64a0f8f437f38b5f3b8ec5b4abdb864e" title="array that holds the water height for each element ">h</a> or momentum (<a class="el" href="classSWE__Block.html#aec2c1278fdb23f083216d8d397f26060" title="array that holds the x-component of the momentum for each element (water height h multiplied by veloc...">hu</a> and <a class="el" href="classSWE__Block.html#a0897aa3c2d78749f209c95e08196d831" title="array that holds the y-component of the momentum for each element (water height h multiplied by veloc...">hv</a>) or bathymetry <a class="el" href="classSWE__Block.html#af7487209129f40b26ea171762754a261" title="array that holds the bathymetry data (sea floor elevation) for each element ">b</a>;</li>
<li><a class="el" href="classSWE__Block.html#a4657993ebdb5f0132b077e63790d0b2b">synchGhostLayerAfterWrite()</a> to synchronize only the ghost layers</li>
<li><a class="el" href="classSWE__Block.html#a23d936cb9a4367092e5b2515f81fe819">synchBeforeRead()</a> to synchronize <a class="el" href="classSWE__Block.html#a64a0f8f437f38b5f3b8ec5b4abdb864e" title="array that holds the water height for each element ">h</a>, <a class="el" href="classSWE__Block.html#aec2c1278fdb23f083216d8d397f26060" title="array that holds the x-component of the momentum for each element (water height h multiplied by veloc...">hu</a>, <a class="el" href="classSWE__Block.html#a0897aa3c2d78749f209c95e08196d831" title="array that holds the y-component of the momentum for each element (water height h multiplied by veloc...">hv</a>, and <a class="el" href="classSWE__Block.html#af7487209129f40b26ea171762754a261" title="array that holds the bathymetry data (sea floor elevation) for each element ">b</a> before an output of the variables (writing a visualization file, e.g.)</li>
<li><a class="el" href="classSWE__Block.html#a07c85681ab29106c3b164db969899ace">synchWaterHeightBeforeRead()</a>, <a class="el" href="classSWE__Block.html#a3773dcb194212fb8cb40ab8465575aa1">synchDischargeBeforeRead()</a>, <a class="el" href="classSWE__Block.html#a7c8258c6949518ca44f4e9ce89d33b09">synchBathymetryBeforeRead()</a>: as <a class="el" href="classSWE__Block.html#a23d936cb9a4367092e5b2515f81fe819">synchBeforeRead()</a>, but only for the specified variables</li>
<li><a class="el" href="classSWE__Block.html#a13c90d5a6596336013c41e73c8795f83">synchCopyLayerBeforeRead()</a>: synchronizes the copy layer only (i.e., a layer that is to be replicated in a neighbouring <a class="el" href="classSWE__Block.html">SWE_Block</a>.</li>
</ul>
<h3>Derived Classes</h3>
<p>As <a class="el" href="classSWE__Block.html">SWE_Block</a> just provides an abstract base class together with the most important data structures, the implementation of concrete models is the job of respective derived classes (see the class diagram at the top of this page). Similar, parallel implementations that are based on a specific parallel programming model (such as OpenMP) or parallel architecture (such as GPU/CUDA) should form subclasses of their own. Please refer to the documentation of these classes for more details on the model and on the parallelisation approach. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a114ed3bb6a8a2c482e5f94f768543b82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SWE_Block::SWE_Block </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l_nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l_ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>l_dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>l_dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor: allocate variables for simulation</p>
<p>unknowns h (water height), hu,hv (discharge in x- and y-direction), and b (bathymetry) are defined on grid indices [0,..,nx+1]*[0,..,ny+1] -&gt; computational domain is [1,..,nx]*[1,..,ny] -&gt; plus ghost cell layer</p>
<p>The constructor is protected: no instances of <a class="el" href="classSWE__Block.html">SWE_Block</a> can be generated. </p>

</div>
</div>
<a class="anchor" id="a2ddff1c284663ba514985a3574def1b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SWE_Block::~SWE_Block </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor: de-allocate all variables </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="acf2ff6617cbc0d3d837f0e618039cfe2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::computeMaxTimestep </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>i_dryTol</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>i_cflNumber</em> = <code>0.4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the largest allowed time step for the current grid block (reference implementation) depending on the current values of variables h, hu, and hv, and store this time step size in member variable maxTimestep.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_dryTol</td><td>dry tolerance (dry cells do not affect the time step). </td></tr>
    <tr><td class="paramname">i_cflNumber</td><td>CFL number of the used method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a94dcf2c6ae31731e4586e45628b0c00e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SWE_Block::computeNumericalFluxes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the numerical fluxes for each edge of the Cartesian grid </p>
<p>The computation of fluxes strongly depends on the chosen numerical method. Hence, this purely virtual function has to be implemented in the respective derived classes. </p>

<p>Implemented in <a class="el" href="classSWE__WavePropagationBlockSIMD.html#a4aa15050ec1db113f54fff06539a900f">SWE_WavePropagationBlockSIMD</a>, <a class="el" href="classSWE__DimensionalSplitting.html#a84759f8fbbbfe1e46613375515826f0f">SWE_DimensionalSplitting</a>, <a class="el" href="classSWE__WavePropagationBlock.html#a5f6335a38fb3cf38623326959f06baf4">SWE_WavePropagationBlock</a>, <a class="el" href="classSWE__WavePropagationBlockCuda.html#a8a89bf61b9fc4433652f400ca8e564ed">SWE_WavePropagationBlockCuda</a>, <a class="el" href="classSWE__WaveAccumulationBlock.html#acac0b73f22b256bc91a58ff8d0831e5d">SWE_WaveAccumulationBlock</a>, <a class="el" href="classSWE__RusanovBlock.html#a78cdefa510cd2d88ca4e213f75b9b10b">SWE_RusanovBlock</a>, and <a class="el" href="classSWE__RusanovBlockCUDA.html#a85ec49606ab69ded8cd6f39aa4be1505">SWE_RusanovBlockCUDA</a>.</p>

</div>
</div>
<a class="anchor" id="a98e2c99a335d11d09a1489d6873b5615"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFloat2D.html">Float2D</a> &amp; SWE_Block::getBathymetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>provides read access to the bathymetry data </p>
<p>return reference to bathymetry unknown b </p>

</div>
</div>
<a class="anchor" id="ae5e766626a1e3fee89625610e2c67f1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFloat2D.html">Float2D</a> &amp; SWE_Block::getDischarge_hu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>provides read access to the momentum/discharge array (x-component) </p>
<p>return reference to discharge unknown hu </p>

</div>
</div>
<a class="anchor" id="aece9e8dc3f9b8ab27420e537c76daf7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFloat2D.html">Float2D</a> &amp; SWE_Block::getDischarge_hv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>provides read access to the momentum/discharge array (y-component) </p>
<p>return reference to discharge unknown hv </p>

</div>
</div>
<a class="anchor" id="a74da1eb712e639e47b5b848081b2afad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SWE_Block::getMaxTimestep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return maximum size of the time step to ensure stability of the method </p>
<dl class="section return"><dt>Returns</dt><dd>current value of the member variable <a class="el" href="classSWE__Block.html#a05cbc9b40e0483bf73dbc2bdeae7dee3" title="maximum time step allowed to ensure stability of the method ">maxTimestep</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab1aea4294403c194180c3dc107339fd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFloat2D.html">Float2D</a> &amp; SWE_Block::getWaterHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>provides read access to the water height array </p>
<p>return reference to water height unknown h </p>

</div>
</div>
<a class="anchor" id="a9a96c59444645e237d098803009158a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSWE__Block1D.html">SWE_Block1D</a> * SWE_Block::grabGhostLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SWE__Scenario_8hh.html#aa5e01e3f7df312f7b9b0d02521141fcc">BoundaryEdge</a>&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"grab" the ghost layer in order to set these values externally </p>
<p>"grab" the ghost layer at the specific boundary in order to set boundary values in this ghost layer externally. The boundary conditions at the respective ghost layer is set to PASSIVE, such that the grabbing program component is responsible to provide correct values in the ghost layer, for example by receiving data from a remote copy layer via MPI communication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">specified</td><td>edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="structSWE__Block1D.html">SWE_Block1D</a> object that contains row variables h, hu, and hv </dd></dl>

<p>Reimplemented in <a class="el" href="classSWE__BlockCUDA.html#ab8671269d89d544a333a0b8c0fa72f37">SWE_BlockCUDA</a>.</p>

</div>
</div>
<a class="anchor" id="a46b715c584468a5daa975ec1eb1ab947"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::initScenario </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_offsetX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_offsetY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSWE__Scenario.html">SWE_Scenario</a> &amp;&#160;</td>
          <td class="paramname"><em>i_scenario</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>i_multipleBlocks</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initialise unknowns to a specific scenario: </p>
<p>Initializes the unknowns and bathymetry in all grid cells according to the given <a class="el" href="classSWE__Scenario.html">SWE_Scenario</a>.</p>
<p>In the case of multiple SWE_Blocks at this point, it is not clear how the boundary conditions should be set. This is because an isolated <a class="el" href="classSWE__Block.html">SWE_Block</a> doesn't have any in information about the grid. Therefore the calling routine, which has the information about multiple blocks, has to take care about setting the right boundary conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_scenario</td><td>scenario, which is used during the setup. </td></tr>
    <tr><td class="paramname">i_multipleBlocks</td><td>are the multiple SWE_blocks? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a827ee5c61dc9c1b472ac8b4e1c19956a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSWE__Block1D.html">SWE_Block1D</a> * SWE_Block::registerCopyLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SWE__Scenario_8hh.html#aa5e01e3f7df312f7b9b0d02521141fcc">BoundaryEdge</a>&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a pointer to proxy class to access the copy layer </p>
<p>register the row or column layer next to a boundary as a "copy layer", from which values will be copied into the ghost layer or a neighbour; </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="structSWE__Block1D.html">SWE_Block1D</a> object that contains row variables h, hu, and hv </dd></dl>

<p>Reimplemented in <a class="el" href="classSWE__BlockCUDA.html#a22782766fc679ac14e9ba30a4efc1688">SWE_BlockCUDA</a>.</p>

</div>
</div>
<a class="anchor" id="af2ab34b138a14f2c295849f3b2acc5f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::setBathymetry </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the bathymetry to a uniform value </p>
<p>set Bathymetry b in all grid cells (incl. ghost/boundary layers) to a uniform value bathymetry source terms are re-computed </p>

</div>
</div>
<a class="anchor" id="ad4214fcfd102a4c167d274ad87d9dd90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::setBathymetry </td>
          <td>(</td>
          <td class="paramtype">float(*)(float, float)&#160;</td>
          <td class="paramname"><em>_b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the bathymetry according to a given function </p>
<p>set Bathymetry b in all grid cells (incl. ghost/boundary layers) using the specified bathymetry function; bathymetry source terms are re-computed </p>

</div>
</div>
<a class="anchor" id="ab2e750bb5e8a952cd9f771054cb4e7b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::setBathymetry </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the whole bathymetry matrix </p>
<p>Restores values for h, v, and u from file data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_b</td><td>array holding b-values in sequence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54d2adb939d59e064edd7316faae445f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::setBathymetry </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>i_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set one single cell's bathymetry value </p>
<p>Sets the bathymetry value at one single cell</p>
<p>Assumption: User has no knowledge of ghost layer. if nx and ny were both zero, the only valid input for (i_x, i_y) would be (0, 0) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_b</td><td>new bathymetry value </td></tr>
    <tr><td class="paramname">i_x</td><td>x-coordinate of the cell </td></tr>
    <tr><td class="paramname">i_y</td><td>y-coordinate of the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6beb68dacde9c8479647c25c6a5cbcf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::setBoundaryBathymetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the bathymetry on OUTFLOW or WALL boundaries. Should be called very time a boundary is changed to a OUTFLOW or WALL boundary <b>or</b> the bathymetry changes. </p>

</div>
</div>
<a class="anchor" id="a379807f0bf932b40aeb42065633fce60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::setBoundaryConditions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set boundary conditions in ghost layers (set boundary conditions) </p>
<p>set the values of all ghost cells depending on the specifed boundary conditions</p>
<ul>
<li>set boundary conditions for typs WALL and OUTFLOW</li>
<li>derived classes need to transfer ghost layers </li>
</ul>

<p>Reimplemented in <a class="el" href="classSWE__BlockCUDA.html#a7cf66067cb7f023aadbd910051d389c8">SWE_BlockCUDA</a>.</p>

</div>
</div>
<a class="anchor" id="aa220b93e43b10f56c72a44d7363645c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::setBoundaryType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SWE__Scenario_8hh.html#aa5e01e3f7df312f7b9b0d02521141fcc">BoundaryEdge</a>&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SWE__Scenario_8hh.html#af75d5dd7322fa39ed0af4e7839e600f8">BoundaryType</a>&#160;</td>
          <td class="paramname"><em>boundtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSWE__Block1D.html">SWE_Block1D</a> *&#160;</td>
          <td class="paramname"><em>i_inflow</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set type of boundary condition for the specified boundary </p>
<p>Set the boundary type for specific block boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_edge</td><td>location of the edge relative to the SWE_block. </td></tr>
    <tr><td class="paramname">i_boundaryType</td><td>type of the boundary condition. </td></tr>
    <tr><td class="paramname">i_inflow</td><td>pointer to an <a class="el" href="structSWE__Block1D.html">SWE_Block1D</a>, which specifies the inflow (should be NULL for WALL or OUTFLOW boundary) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a245332c325fd0ff6a7e9c2d3d9454970"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::setDischarge </td>
          <td>(</td>
          <td class="paramtype">float(*)(float, float)&#160;</td>
          <td class="paramname"><em>_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float(*)(float, float)&#160;</td>
          <td class="paramname"><em>_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the momentum/discharge according to the provided functions </p>
<p>set discharge in all interior grid cells (i.e. except ghost layer) to values specified by parameter functions Note: unknowns hu and hv represent momentum, while parameters u and v are velocities! </p>

</div>
</div>
<a class="anchor" id="afd17334abee3145e27cc3c9b7b935da2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::setGhostLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set values in ghost layers </p>
<p>set the values of all ghost cells depending on the specifed boundary conditions; if the ghost layer replicates the variables of a remote <a class="el" href="classSWE__Block.html">SWE_Block</a>, the values are copied </p>

</div>
</div>
<a class="anchor" id="a6481ce1c80a219fbefefdcbd13ed3688"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::setWaterHeight </td>
          <td>(</td>
          <td class="paramtype">float(*)(float, float)&#160;</td>
          <td class="paramname"><em>_h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the water height according to a given function </p>
<p>set water height h in all interior grid cells (i.e. except ghost layer) to values specified by parameter function _h </p>

</div>
</div>
<a class="anchor" id="a69784e2be2d09035fb2af9d306768f07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SWE_Block::simulate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>i_tStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>i_tEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>perform the simulation starting with simulation time tStart, until simulation time tEnd is reached</p>
<p>simulate implements the main simulation loop between two checkpoints; Note: this implementation can only be used, if you only use a single <a class="el" href="classSWE__Block.html">SWE_Block</a> and only apply simple boundary conditions! In particular, <a class="el" href="classSWE__Block.html#a69784e2be2d09035fb2af9d306768f07">SWE_Block::simulate</a> can not trigger calls to exchange values of copy and ghost layers between blocks! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tStart</td><td>time where the simulation is started </td></tr>
    <tr><td class="paramname">tEnd</td><td>time of the next checkpoint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>actual end time reached </dd></dl>

<p>Reimplemented in <a class="el" href="classSWE__WavePropagationBlockSIMD.html#a6c54dbcd43a77b46bae4de36b8d16af7">SWE_WavePropagationBlockSIMD</a>, <a class="el" href="classSWE__WavePropagationBlockCuda.html#a8c0fbb70ad29f3775d35978bf2d5b396">SWE_WavePropagationBlockCuda</a>, <a class="el" href="classSWE__RusanovBlockCUDA.html#a77719262dc1789adea136ed50f17bb58">SWE_RusanovBlockCUDA</a>, and <a class="el" href="classSWE__RusanovBlock.html#a645322106b3e5b6f0cca077611ad2159">SWE_RusanovBlock</a>.</p>

</div>
</div>
<a class="anchor" id="add6908e1ceb261a0a1f3ebc262cc5f11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::simulateTimestep </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>execute a single time step (with fixed time step size) of the simulation </p>
<p>Executes a single timestep with fixed time step size</p>
<ul>
<li>compute net updates for every edge</li>
<li>update cell values with the net updates</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>time step width of the update </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSWE__WavePropagationBlockSIMD.html#a99c288632c402eaf7dff76f03624872a">SWE_WavePropagationBlockSIMD</a>, <a class="el" href="classSWE__WavePropagationBlockCuda.html#ab401d17ea7a60ff30219076bc85dc591">SWE_WavePropagationBlockCuda</a>, <a class="el" href="classSWE__RusanovBlockCUDA.html#a238b383e0458babb52e3dd5b5784bc48">SWE_RusanovBlockCUDA</a>, and <a class="el" href="classSWE__RusanovBlock.html#ada062db4f54700011d50378b0045830a">SWE_RusanovBlock</a>.</p>

</div>
</div>
<a class="anchor" id="ae914f9bf6d4ef8f974f9f005114985e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::synchAfterWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update all temporary and non-local (for heterogeneous computing) variables after an external update of the main variables h, hu, hv, and b. </p>

<p>Reimplemented in <a class="el" href="classSWE__BlockCUDA.html#a0876ef53f667c142d7d4dd9d01cfd2dc">SWE_BlockCUDA</a>.</p>

</div>
</div>
<a class="anchor" id="a4bece8aa90f67e55c40b91aab900febb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::synchBathymetryAfterWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update temporary and non-local (for heterogeneous computing) variables after an external update of the bathymetry b </p>

<p>Reimplemented in <a class="el" href="classSWE__BlockCUDA.html#aef79c805fec82b4d439642a758a8e95f">SWE_BlockCUDA</a>.</p>

</div>
</div>
<a class="anchor" id="a7c8258c6949518ca44f4e9ce89d33b09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::synchBathymetryBeforeRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update temporary and non-local (for heterogeneous computing) variables before an external access to the bathymetry b </p>

<p>Reimplemented in <a class="el" href="classSWE__BlockCUDA.html#a3edd34c86eb0837d09f24cbf56a16e69">SWE_BlockCUDA</a>.</p>

</div>
</div>
<a class="anchor" id="a23d936cb9a4367092e5b2515f81fe819"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::synchBeforeRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update all temporary and non-local (for heterogeneous computing) variables before an external access to the main variables h, hu, hv, and b. </p>

<p>Reimplemented in <a class="el" href="classSWE__BlockCUDA.html#a9ba846c6fa27734412d9fdfaa3823de2">SWE_BlockCUDA</a>.</p>

</div>
</div>
<a class="anchor" id="a13c90d5a6596336013c41e73c8795f83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::synchCopyLayerBeforeRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update (for heterogeneous computing) variables in copy layers before an external access to the unknowns </p>

<p>Reimplemented in <a class="el" href="classSWE__BlockCUDA.html#a41d117ca8fe9a8c5509369edd026fd63">SWE_BlockCUDA</a>.</p>

</div>
</div>
<a class="anchor" id="a94c34030153178c9d94f3f14be174eaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::synchDischargeAfterWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update temporary and non-local (for heterogeneous computing) variables after an external update of the discharge variables hu and hv </p>

<p>Reimplemented in <a class="el" href="classSWE__BlockCUDA.html#a71b1d0b2e6959c298dfccf6a36264e13">SWE_BlockCUDA</a>.</p>

</div>
</div>
<a class="anchor" id="a3773dcb194212fb8cb40ab8465575aa1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::synchDischargeBeforeRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update temporary and non-local (for heterogeneous computing) variables before an external access to the discharge variables hu and hv </p>

<p>Reimplemented in <a class="el" href="classSWE__BlockCUDA.html#adea7daf7794147d73d9465d37b37055e">SWE_BlockCUDA</a>.</p>

</div>
</div>
<a class="anchor" id="a4657993ebdb5f0132b077e63790d0b2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::synchGhostLayerAfterWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the ghost layers (only for CONNECT and PASSIVE boundary conditions) after an external update of the main variables h, hu, hv, and b in the ghost layer. </p>

<p>Reimplemented in <a class="el" href="classSWE__BlockCUDA.html#ab9cc911c9d67bcab9ecb2818a056930b">SWE_BlockCUDA</a>.</p>

</div>
</div>
<a class="anchor" id="aa2924833e29a795d8c04fb79bfe794de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::synchWaterHeightAfterWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update temporary and non-local (for heterogeneous computing) variables after an external update of the water height h </p>

<p>Reimplemented in <a class="el" href="classSWE__BlockCUDA.html#ae54054af51e68415a68f3a1c7b25c139">SWE_BlockCUDA</a>.</p>

</div>
</div>
<a class="anchor" id="a07c85681ab29106c3b164db969899ace"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SWE_Block::synchWaterHeightBeforeRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update temporary and non-local (for heterogeneous computing) variables before an external access to the water height h </p>

<p>Reimplemented in <a class="el" href="classSWE__BlockCUDA.html#adfd3185b108632b2506558063714d7df">SWE_BlockCUDA</a>.</p>

</div>
</div>
<a class="anchor" id="ab2b4b659f23d5d45413dece8d2da3298"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SWE_Block::updateUnknowns </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the new values of the unknowns h, hu, and hv in all grid cells </p>
<p>based on the numerical fluxes (computed by computeNumericalFluxes) and the specified time step size dt, an Euler time step is executed. As the computational fluxes will depend on the numerical method, this purely virtual function has to be implemented separately for each specific numerical model (and parallelisation approach). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>size of the time step </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classSWE__DimensionalSplitting.html#af74b527ff9ca7727442db92d2e438531">SWE_DimensionalSplitting</a>, <a class="el" href="classSWE__WavePropagationBlockSIMD.html#a2596238868efd3cdd453d9ac2de15997">SWE_WavePropagationBlockSIMD</a>, <a class="el" href="classSWE__WavePropagationBlock.html#a1b1422472a36602b34180e4ed27f6d8c">SWE_WavePropagationBlock</a>, <a class="el" href="classSWE__WavePropagationBlockCuda.html#a4163045a47a73515841e754ca3859fc5">SWE_WavePropagationBlockCuda</a>, <a class="el" href="classSWE__WaveAccumulationBlock.html#a67b78723e81aec6e661b3710e6c41b43">SWE_WaveAccumulationBlock</a>, <a class="el" href="classSWE__RusanovBlock.html#a2980aa21030ba8fc607001ad817d7454">SWE_RusanovBlock</a>, and <a class="el" href="classSWE__RusanovBlockCUDA.html#a0a18726a733492218423eed37a7ab406">SWE_RusanovBlockCUDA</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a05cbc9b40e0483bf73dbc2bdeae7dee3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SWE_Block::maxTimestep</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maximum time step allowed to ensure stability of the method </p>
<p>maxTimestep can be updated as part of the methods computeNumericalFluxes and updateUnknowns (depending on the numerical method) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/blocks/<a class="el" href="SWE__Block_8hh_source.html">SWE_Block.hh</a></li>
<li>src/blocks/<a class="el" href="SWE__Block_8cpp.html">SWE_Block.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 19 2015 17:00:09 for SWE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
