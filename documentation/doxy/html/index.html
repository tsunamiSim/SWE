<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>SWE: SWE - A Simple Shallow Water Code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SWE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">SWE - A Simple Shallow Water Code </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>SWE is a teaching code that implements simple Finite Volumes models that solve the shallow water equations - in a problem setting as it would be used for tsunami simulation.</p>
<h1><a class="anchor" id="intro"></a>
The Shallow Water Equations</h1>
<p>The shallow water equations describe the behaviour of a fluid, in particular water, of a certain (possibly varying) depth <em>h</em> in a two-dimensional domain &ndash; imagine, for example, a puddle of water or a shallow pond (and compare the 1D sketch given below). The main modelling assumption is that we can neglect effects of flow in vertical direction. The resulting model proved to be useful for the simulation of tsunami propagation (with appropriate extensions). While an ocean can hardly be considered as "shallow" in the usual sense, tsunami waves (in contrast to regular waves induced by wind, e.g.) affect the entire water column, such that effects of vertical flow can again be neglected. To allow for a non-even sea bottom (as required for accurate modelling of tsunamis), we include the elevation <em>b</em> of the sea floor in our model:</p>
 <div class="image">
<img src="basin_bathy.gif" alt="basin_bathy.gif"/>
</div>
<p>The shallow water equations describe the changes of water depth <em>h</em> and horizontal velocities <em>v<sub>x</sub></em> and <em>v<sub>y</sub></em> (in the resp. coordinate directions) over time, depending on some initial conditions &ndash; in the case of tsunami simulation, these initial conditions could, for example, result from an initial elevation of the sea floor caused by an earthquake. The respective changes in time can be described via a system of partial differential equations: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{array}{c} \displaystyle \frac{\partial h}{\partial t} + \frac{\partial (v_x h)}{\partial x} + \frac{\partial (v_y h)}{\partial y} = 0 \\[1em] \displaystyle \frac{\partial (h v_x)}{\partial t} + \frac{\partial (h v_x v_x)}{\partial x} + \frac{\partial (h v_y v_x)}{\partial y} + \frac{1}{2} g \frac{\partial (h^2)}{\partial x} = - gh \frac{\partial b}{\partial x}, \\[1em] \displaystyle \frac{\partial (h v_y)}{\partial t} + \frac{\partial (h v_x v_y)}{\partial x} + \frac{\partial (h v_y v_y)}{\partial y} + \frac{1}{2} g \frac{\partial (h^2)}{\partial y} = - gh \frac{\partial b}{\partial y}, \end{array} \]" src="form_0.png"/>
</p>
<p> The equation for <em>h</em> is obtained, if we examine the conservation of mass in a control volume. The equations for <em>hv<sub>x</sub></em> and <em>hv<sub>y</sub></em> result from conservation of momentum (note that <em>h</em> is directly related to the volume, and thus the mass of the water &ndash; thus <em>hv<sub>x</sub></em> can be interpreted as a momentum).</p>
<p>The two terms involving <em>g</em> model a gravity-induced force (<em>g</em> being the constant for the gravitational acceleration, <em>g</em> = 9.81 ms<sup>-2</sup>), which results from the hydrostatic pressure. The right-hand-side source terms model the effect of an uneven ocean floor (<em>b</em> obtained from respective bathymetry data).</p>
<h2><a class="anchor" id="finvol"></a>
Finite Volume Discretisation</h2>
<p>The shallow water equations are usually too difficult to be solved exactly - hence, SWE implements simple discrete models as an approximation. As the applied numerical method (typically a Finite Volume discretization) may vary, we will stick to the basics at this point.</p>
<p>First, SWE assumes that the unknown functions <em>h(t,x,y)</em>, <em>hu(t,x,y) := h(t,x,y) v<sub>x</sub>(t,x,y)</em>, <em>hv(t,x,y) := h(t,x,y) v<sub>y</sub>(t,x,y)</em>, as well as the given sea bottom level <em>b(x,y)</em>, are approximated on a Cartesian mesh of grid cells, as illustrated below. In each grid cell, with indices <em>(i,j)</em>, the unknowns have constant values <em>h<sub>ij</sub></em>, <em>hu<sub>ij</sub></em>, <em>hv<sub>ij</sub></em>, and <em>b<sub>ij</sub></em>:</p>
<div class="image">
<img src="grid_unknowns.gif" alt="grid_unknowns.gif"/>
</div>
 <h2><a class="anchor" id="fluxes"></a>
Computing Numerical Fluxes at Edges and Euler Time-Stepping</h2>
<p>The details of the numerical schemes are too complicated to be described in this overview. Please refer to the accompanying material. To put it short, we successively perform two main computational steps:</p>
<ul>
<li>we compute so-called <b>numerical fluxes</b> on each edge of the grid (which approximate the transfer of mass or momentum between grid cells),</li>
<li>based on these numerical fluxes, we then update the unknowns in each cell.</li>
</ul>
<h1><a class="anchor" id="impl"></a>
Implementation and base class SWE_Block</h1>
<p>For the simulation of the shallow water model, we thus require a regular Cartesian grid, where each grid cell carries the respective unknowns - water level, momentum in x- and y-direction, and bathymetry data. The central data structures for Cartesian grid and arrays of unknowns are provided with the abstract base class <a class="el" href="classSWE__Block.html">SWE_Block</a>, which has four 2D arrays <a class="el" href="classSWE__Block.html#a64a0f8f437f38b5f3b8ec5b4abdb864e" title="array that holds the water height for each element ">SWE_Block::h</a>, <a class="el" href="classSWE__Block.html#aec2c1278fdb23f083216d8d397f26060" title="array that holds the x-component of the momentum for each element (water height h multiplied by veloc...">SWE_Block::hu</a>, <a class="el" href="classSWE__Block.html#a0897aa3c2d78749f209c95e08196d831" title="array that holds the y-component of the momentum for each element (water height h multiplied by veloc...">SWE_Block::hv</a>, and <a class="el" href="classSWE__Block.html#af7487209129f40b26ea171762754a261" title="array that holds the bathymetry data (sea floor elevation) for each element ">SWE_Block::b</a>. To implement the behaviour of the fluid at boundaries, and also to allow the connection of several grid blocks (for parallelization or just to build more complicated computational domains), each array has an additional layer of so-called <em>ghost cells</em>, as illustrated in the following figure:</p>
 <div class="image">
<img src="ghost_cells.gif" alt="ghost_cells.gif"/>
</div>
<h2><a class="anchor" id="models"></a>
Parallelisation and Different Models</h2>
<p>In each time step, our numerical algorithm will compute the flux terms for each edge of the computational domain. To compute the fluxes, we require the values of the unknowns in both adjacent cells. At the boundaries of the fluid domain, the ghost layer makes sure that we also have two adjacent cells for the cell edges on the domain boundary. The values in the ghost layer cells will be set to values depending on the values in the adjacent fluid domain. We will model three different situations: {description} {Outflow:} {h}, {u}, and {v} in the ghost cell are set to the same value as in the adjacent fluid cell. This models the situation that the unknowns do not change across the domain boundary (undisturbed outflow). {Wall:} At a wall, the velocity component normal to the boundary should be $0$, such that no fluid can cross the boundary. To model this case, we set the normal velocity, e.g. {u[0]} at the left boundary, to the negative value of the adjacent cell: {-u[1]}. The interpolated value at the boundary edge will then be $0$ ({h} is identical in both cells due to the imposed boundary condition). The other two variables are set in the same way as for the outflow situation. {Connect:} With the connect case, we can connect a domain at two boundaries. If we connect the left and right boundary, we will obtain a periodically repeated domain. Here, all ghost values are determined by the values of the unknowns in the fluid cell adjacent to the connected boundary. {description}</p>
<p>To implement the boundary conditions, the class {<a class="el" href="classSWE__Block.html">SWE_Block</a>} contains an array of four enum variables, {boundary[4]} (for left/right/bottom/top boundary), that can take the values <code>OUTFLOW</code>, <code>WALL</code>, and <code>CONNECT</code>.</p>
<h2><a class="anchor" id="multblocks"></a>
Multiple Blocks</h2>
<p>Via the connect boundary condition, it is also possible to connect several Cartesian grid blocks to build a more complicated domain. Figure fig:connect} illustrates the exchange of ghost values for two connected blocks.</p>
<div class="image">
<img src="connect.gif" alt="connect.gif"/>
</div>
 <p>To store the neighbour block in case of a <code>CONNECT</code> boundary, <code><a class="el" href="classSWE__Block.html">SWE_Block</a></code> contains a further array of four pointers, <code>neighbour[4]</code> (for left/right/bottom/top boundary), that will store a pointer to the connected adjacent <code><a class="el" href="classSWE__Block.html">SWE_Block</a></code>.</p>
<p>The respective block approach can also be exploited for parallelisation: the different blocks would then be assigned to the available processors (or processor cores) &ndash; each processor (core) works on its share of blocks, while the program has to make sure to keep the values in the ghost cells up to date (which requires explicit communication in the case of distributed-memory computers).</p>
<h2><a class="anchor" id=""></a>
</h2>
<p>For each time step, our solver thus performs the following steps &ndash; each step is implemented via a separate member function of the class {<a class="el" href="classSWE__Block.html">SWE_Block</a>}: {enumerate}  set the values at the boundaries: {setBoundaryLayer()};  compute the flux terms for all edges: {computeFluxes()};  from the flux terms, compute the in/outflow balance for each cell, and compute the new values of the unknowns for the next time step: {eulerTimestep()}. {enumerate}</p>
<h2><a class="anchor" id=""></a>
</h2>
<p>The class {<a class="el" href="classSWE__Block.html">SWE_Block</a>} contains further methods that will write the numerical solution into a sequence of files that can be read by the visualisation package ParaView (just enter the respective folder from ParaView &ndash; the files will be recognised and displayed as one project). ParaView allows to visualise the computed time-dependent solution (as ``movie'' or in single-step mode). ParaView is pretty self-explanatory for our purposes, but provides an online help for further instructions.</p>
<h2><a class="anchor" id=""></a>
</h2>
<p>We also provide a CUDA implementation of the simulation code (requires a computer with a CUDA-capable GPU, together with the respective drivers &ndash; visit NVIDIA's website on CUDA for details on implementation). Apart from the fact that the simulation usually runs a lot faster on the GPU, the program is also capable of plotting the computing solution (water surface) ``on the fly''.</p>
<p>Finally: whoever thinks that they can do a better (faster, ...) implementation (visualisation, ...) of the provided code is more than welcome to do so! Feel free to contribute to SWE - for questions, just contact Michael Bader (<a href="#" onclick="location.href='mai'+'lto:'+'bad'+'er'+'@in'+'.t'+'um.'+'de'; return false;">bader<span style="display: none;">.nosp@m.</span>@in.<span style="display: none;">.nosp@m.</span>tum.d<span style="display: none;">.nosp@m.</span>e</a>). </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 19 2015 17:00:11 for SWE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
